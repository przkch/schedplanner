---
import AddSchedule from "@components/modals/AddSchedule.svelte";
import TableHeaders from "@components/schedule/TableHeaders.astro";
import { db } from "@lib/database";
import { employee, schedule, shift, group, holiday, shiftTypes } from "@lib/database/schema";
import { fmtShift } from "@lib/utils";
import { getDays } from "@lib/utils/date";

import * as m from "@paraglide/messages";
import { and, eq, inArray, sql } from "drizzle-orm";

interface Props {
  year: number;
  month: number;
}

const { year, month } = Astro.props;

const teamId = Astro.cookies.get("current_team_id")!.number();

const employees = await db.select().from(employee).where(eq(employee.teamId, teamId)).orderBy(employee.firstName, employee.lastName);
const groups = await db.select().from(group).where(eq(group.teamId, teamId));

const employees_ids = employees.flatMap((e) => {
  return e.id;
});

const employees_schedule = await db
  .select({
    employeeId: schedule.employeeId,
    shiftId: shift.id,
    year: schedule.year,
    month: schedule.month,
    day: schedule.day,
    label: shift.label,
    start: shift.start,
    end: shift.end,
    color: shift.color,
    shiftType: shift.shiftType,
  })
  .from(schedule)
  .where(and(eq(schedule.year, year), eq(schedule.month, month), inArray(schedule.employeeId, employees_ids)))
  .leftJoin(shift, eq(schedule.shiftId, shift.id))
  .leftJoin(employee, eq(schedule.employeeId, employee.id))
  .orderBy(schedule.day);

const full_schedule = {};
const total_hours = {};
const shift_counts = {};

interface EmployeeSchedule {
  label: string;
  start: string;
  end: string;
  color: string;
  shiftType: typeof shiftTypes.enumValues;
}

for (const s of employees_schedule) {
  if (!(s.employeeId in full_schedule)) {
    full_schedule[s.employeeId] = {};
  }

  if (!s.shiftId || !s.start || !s.end || !s.color) {
    console.log(`No shift start found for day ${s.day}`);
    continue;
  }

  full_schedule[s.employeeId][s.day] = {
    label: s.label,
    start: fmtShift(s.start),
    end: fmtShift(s.end),
    color: s.color,
    shiftType: s.shiftType,
  };

  const shift_hours =
    Math.abs(Date.parse(`${s.year}-${s.month}-${s.day} ${s.end}`) - Date.parse(`${s.year}-${s.month}-${s.day} ${s.start}`)) / (60 * 60 * 1000);

  if (!["VACATION", "LEAVE_ON_REQUEST"].includes(s.shiftType as string)) {
    if (!(s.employeeId in total_hours)) {
      total_hours[s.employeeId] = 0;
    }
    total_hours[s.employeeId] += shift_hours;
  }

  if (!(s.shiftId in shift_counts)) {
    shift_counts[s.shiftId] = {};
  }

  if (!(s.day in shift_counts[s.shiftId])) {
    shift_counts[s.shiftId][s.day] = 0;
  }

  if (!("total" in shift_counts[s.shiftId])) {
    shift_counts[s.shiftId].total = 0;
  }

  shift_counts[s.shiftId][s.day] += 1;
  shift_counts[s.shiftId].total += 1;
}

const shifts = await db.select().from(shift);
const holidays = await db
  .select()
  .from(holiday)
  .where(sql.raw(`date::text LIKE '${year.toString()}-%'`));

const days = getDays(year, month, holidays);
---

<div class="overflow-auto h-[calc(100vh-7.5rem)]">
  {
    employees.length && groups.length ? (
      <table class="table-auto border-collapse text-sm">
        <TableHeaders holidays={holidays} year={year} month={month} />
        {groups.map((group) => {
          return (
            <>
              <tr>
                <td class="font-bold uppercase text-center">{group.name}</td>
              </tr>
              {employees
                .filter((employee) => employee.groupId === group.id)
                .map((employee) => {
                  return (
                    <tr>
                      <td class="px-4 whitespace-nowrap h-fit border-1">
                        {employee.firstName} {employee.lastName}
                      </td>
                      {days.map((d) => {
                        let employee_schedule: EmployeeSchedule | undefined = undefined;

                        if (employee.id in full_schedule && d.idx in full_schedule[employee.id]) {
                          employee_schedule = full_schedule[employee.id][d.idx];
                        }

                        return (
                          <td
                            style={{ backgroundColor: employee_schedule?.color }}
                            class:list={[
                              "hover:bg-opacity-50 transition-colors border-1 selectable",
                              {
                                "bg-gray-300 text-gray-800": !employee_schedule?.color && d.isToday,
                                "bg-custom-holiday": !employee_schedule?.color && d.isFree,
                              },
                            ]}
                            data-employee={employee.id}
                            data-day={d.idx}
                            title={
                              employee_schedule?.label
                                ? `Shift ${employee_schedule.label}\n${employee_schedule.start} - ${employee_schedule.end}\n${employee_schedule.shiftType}`
                                : "Click to add shift"
                            }
                          >
                            <button class="flex flex-col items-center justify-center size-8 selectable" data-employee={employee.id} data-day={d.idx}>
                              {employee_schedule?.label ? (
                                employee_schedule.label
                              ) : employee_schedule?.start && employee_schedule?.end ? (
                                <>
                                  {employee_schedule.start}
                                  <br />
                                  {employee_schedule.end}
                                </>
                              ) : null}
                            </button>
                          </td>
                        );
                      })}
                      <td class:list={["border-1 text-xs text-center", { "font-bold": total_hours[employee.id] > 0 }]}>
                        {total_hours[employee.id] ?? 0}
                      </td>
                    </tr>
                  );
                })}
            </>
          );
        })}
        <TableHeaders holidays={holidays} year={year} month={month} footer={true} />
        {shifts
          .filter((s) => shift_counts[s.id])
          .map((s) => {
            return (
              <tr>
                <td class="px-4 h-fit min-w-64 border-1">
                  {s.label ? (
                    s.label
                  ) : (
                    <>
                      <span>{s.shiftType}</span>
                      <span>
                        {fmtShift(s.start)} - {fmtShift(s.end)}
                      </span>
                    </>
                  )}
                </td>
                {days.map((d) => {
                  const count = shift_counts[s.id] && shift_counts[s.id][d.idx] ? shift_counts[s.id][d.idx] : 0;

                  return (
                    <td
                      class:list={[
                        "h-fit text-center border-1",
                        { "bg-custom-holiday text-gray-100": d.isFree },
                        { "bg-gray-300 text-gray-800": d.isToday },
                        { "font-bold": count > 0 },
                      ]}
                    >
                      {count}
                    </td>
                  );
                })}
              </tr>
            );
          })}
      </table>
    ) : (
      <div class="text-center">{m.no_employees()}</div>
    )
  }
  <AddSchedule client:load="svelte" year={year} month={month} day="" employee_id="" shifts={shifts} />
</div>
<style>
  .intersected {
    background-color: theme("colors.gray.600") !important;
  }
</style>
<script>
  interface Selectable {
    x: number;
    y: number;
    width: number;
    height: number;
    elem?: HTMLElement;
  }

  function checkSelected(selectables: Selectable[], selectAreaElem: Element) {
    const { x, y, height, width } = selectAreaElem.getBoundingClientRect();

    for (const selectable of selectables) {
      if (checkRectIntersection({ x: x + window.scrollX, y: y + window.scrollY, height, width }, selectable)) {
        selectable.elem?.classList.add("intersected");
      } else {
        selectable.elem?.classList.remove("intersected");
      }
    }
  }

  const checkRectIntersection = (r1: Selectable, r2: Selectable): boolean => {
    return !(r1.x + r1.width < r2.x || r2.x + r2.width < r1.x || r1.y + r1.height < r2.y || r2.y + r2.height < r1.y);
  };

  const scheduleTable = document.querySelector("table") as HTMLTableElement;
  const tableContainer = scheduleTable.parentElement as HTMLDivElement;
  const modifyScheduleElement = document.querySelector("dialog#modify_schedule") as HTMLDialogElement;
  const employeeIdElement = modifyScheduleElement.querySelector("input[name='employee_id']") as HTMLInputElement;
  const dayElement = modifyScheduleElement.querySelector("input[name='day']") as HTMLInputElement;

  const selectables: Selectable[] = [];
  const selectableElems = [...(document.querySelectorAll(".selectable") as NodeListOf<HTMLElement>)];

  for (const selectable of selectableElems) {
    const { x, y, width, height } = selectable.getBoundingClientRect();
    selectables.push({ x: x + window.scrollX, y: y + window.scrollY, width, height, elem: selectable });
    selectable.dataset.info = JSON.stringify({ x, y, width, height });
  }

  const handlePointerDown = (event: PointerEvent) => {
    const target = event.target as HTMLElement;

    if (event.button !== 0) return;

    if (!target.classList.contains("selectable") && !target.classList.contains("intersected")) return;

    event.preventDefault();

    const x = event.pageX + tableContainer.scrollLeft;
    const y = event.pageY + tableContainer.scrollTop;

    const div = document.createElement("div");
    div.style.position = "absolute";
    div.style.width = "0";
    div.style.height = "0";
    div.style.left = x + "px";
    div.style.top = y + "px";
    div.classList.add("drag-select");
    document.body.append(div);

    const resize = (event: PointerEvent) => {
      const diffX = event.pageX + tableContainer.scrollLeft - x;
      const diffY = event.pageY + tableContainer.scrollTop - y;
      div.style.left = diffX < 0 ? x + diffX + "px" : x + "px";
      div.style.top = diffY < 0 ? y + diffY + "px" : y + "px";
      div.style.height = Math.abs(diffY) + "px";
      div.style.width = Math.abs(diffX) + "px";
      checkSelected(selectables, div);
    };

    const employees: number[] = [];
    const days: number[] = [];

    target.classList.add("intersected");

    resize(event);

    const employee = Number(target.dataset.employee);
    const day = Number(target.dataset.day);

    !employees.includes(employee) && employees.push(employee);
    !days.includes(day) && days.push(day);

    selectables.forEach((item) => item.elem?.classList.remove("intersected"));

    const handlePointerMove = (event: PointerEvent) => {
      resize(event);

      const intersectedElements = [...(document.querySelectorAll(".intersected") as NodeListOf<HTMLElement>)];

      if (intersectedElements.length) {
        intersectedElements.map((elem) => {
          const employee = Number(elem.dataset.employee);
          const day = Number(elem.dataset.day);

          !employees.includes(employee) && employees.push(employee);
          !days.includes(day) && days.push(day);
        });
      }
    };

    document.addEventListener("pointermove", handlePointerMove);

    const handlePointerUp = (event: PointerEvent) => {
      const target = event.target as HTMLElement;

      if (event.button !== 0) return;

      removeEventListener("pointermove", handlePointerMove);

      div.remove();
      selectables.forEach((item) => item.elem?.classList.remove("intersected"));

      if (!target.classList.contains("selectable") && !target.classList.contains("intersected")) return;

      if (employees.length && days.length) {
        employeeIdElement.value = employees.join(",");
        dayElement.value = days.join(",");
      } else {
        return;
      }

      if (!modifyScheduleElement.open) {
        modifyScheduleElement.showModal();
      }
    };

    document.addEventListener("pointerup", handlePointerUp);
  };

  scheduleTable.addEventListener("pointerdown", handlePointerDown);
</script>
